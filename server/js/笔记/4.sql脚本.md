## sql 性能优化

查询时注意：使用索引，避免扫描全表或者索引；复杂的语句，可以先查询出临时表。

1. 任何情况都不要用 select \* from table ，用具体的字段列表替换"\*"，不要返回用不到的字段,避免全盘扫描；
2. 批量插入，只用单条语句；
3. like 语句，必然全表查询，尽量使用最小化的模糊查询；
4. 使用 in 或者 not in 会丢弃索引，从而进行全盘扫描，where 语句中要避免谨慎使用；
   > 1. 使用 between 替换 in
   > 2. exist 替换 in
   > 3. left join 替换 in
5. or 查询会丢掉索引，使用 union all 或 union 替换
6. 尽量用 union all 替换 union
   > union 和 union all 的差异主要是前者需要将两个（或者多个）结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的 cpu 运算，加大资源消耗及延迟。所以当我们可以确认不可能出现重复结果集或者不在乎重复结果集的时候，尽量使用 union all 而不是 union
7. inner join（也叫等值连接）, left join, right join, 子查询
   > 1. 能用 inner join 连接尽量使用 inner join 连接
   > 2. 子查询的性能又比外连接性能慢，尽量用外连接来替换子查询

## 数据库查询

```sql
-- 创建 student 表
DROP TABLE IF EXISTS `student`;
CREATE TABLE `student` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(32) DEFAULT NULL,
  `uid` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- 创建 score 表
DROP TABLE IF EXISTS `score`;
CREATE TABLE `score` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(32) DEFAULT NULL,
  `uid` varchar(32) DEFAULT NULL,
  `subject` varchar(32) DEFAULT NULL,
  `score` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- 插入数据
insert into student(`name`, `uid`) values ('john', '0001'), ('jack', '0002'), ('tom', '0004');
insert into score(`subject`, `score`, `uid`) values ('chinese', '90', '0001'), ('math', '90', '0002'), ('english', '90', '0003');
```

1. inner join / join: 内连接(或者省略 join)

- 返回左右表匹配的数据

```sql
select s1.uid, s2.subject, s2.score from student s1 inner join score s2 on s1.uid = s2.uid;
```

2. left join / left outer join: 左连接

- 左表所有行，右表匹配行，右表无值则为 null

```sql
select s1.uid, s2.subject, s2.score from student s1 left join score s2 on s1.uid = s2.uid;
```

3. right join / right outer join: 右连接

- 右表所有行，左表匹配行，左表无值则为 null

```sql
select s1.uid, s2.subject, s2.score from student s1 right join score s2 on s1.uid = s2.uid;
```

4. full join / full outer join: 完整外连接(mysql 不支持)

- 左连接+右连接，左右表笛卡尔积

5. cross join: 交叉连接

- 没有两表之间关系的交叉连接，将产生连接所涉及表的笛卡尔积

```sql
select s1.uid, s2.subject, s2.score from student s1 cross join score s2;

select s1.uid, s2.subject, s2.score from student s1, score s2;
```

6. 自连接

- 表与自身连接

```sql
select s1.uid, s2.name from student s1, student s2 where s1.uid = s2.uid;
```

7. 子查询: To be continue...

## sequelize

### 关系 association：

- hasOne: 一对一
- hasMany: 一对多
- belongsTo: 一对多
- belongsToMany: 多对多

D 定义 foreignKey 指向 S

```js
S.hasOne(D);
S.hasOne(D);
D.belongsTo(S);
D.belongsToMany(S);
```

### 事务 Transaction类

### include

subQuery，required 属性

## sql 函数